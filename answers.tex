\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage{longtable}
\usepackage{calc}
\usepackage{float}

\usepackage{graphicx}
\usepackage[document]{ragged2e}
\usepackage[a4paper, left=1.5cm]{geometry}

\usepackage{listings}
\usepackage{xcolor}

\newcommand\Que[2]{%
\vspace{10pt}
{\large\textbf{(Q.#1)}}

\vspace{5pt}
#2
}

\newenvironment{ans}
    {\begin{quote}{\large\textbf{(A)}}\\\vspace{5pt}}
    {\end{quote}}
%

\begin{document}

\Que{1}{
What would happen to linked \texttt{mobile} phone actors if the
\texttt{switch} were to terminate abnormally?
}

\begin{ans}
\begin{lstlisting}[basicstyle=\small\ttfamily,breaklines=true]
1> switch:start().
<0.87.0>
[DEBUG - <0.87.0> - switch:88] - Starting switch process.
[TRACE - <0.87.0> - server_gen:132] - Init successful with state: [].
2> switch:subscribe("12121212").
[TRACE - <0.87.0> - server_gen:241] - Handling sync request from PID <0.85.0> of type: {subscribe,"12121212"}.
{ok,subscribed}
3> switch:subscribe("23232323").
[TRACE - <0.87.0> - server_gen:241] - Handling sync request from PID <0.85.0> of type: {subscribe,"23232323"}.
{ok,subscribed}
4> Mob1 = mobile:switch_on("12121212").
[TRACE - <0.87.0> - server_gen:241] - Handling sync request from PID <0.91.0> of type: {attach,<0.91.0>,"12121212"}.
<0.91.0>
[TRACE - <0.91.0> - server_gen:132] - Init successful with state: {"12121212",flight_mode_off}.
5> Mob2 = mobile:switch_on("23232323").
[TRACE - <0.87.0> - server_gen:241] - Handling sync request from PID <0.93.0> of type: {attach,<0.93.0>,"23232323"}.
<0.93.0>
[TRACE - <0.93.0> - server_gen:132] - Init successful with state: {"23232323",flight_mode_off}.
6> mobile:tog_flight_mode(Mob2).
[TRACE - <0.93.0> - server_gen:241] - Handling sync request from PID <0.85.0> of type: tog_flight_mode.
[TRACE - <0.87.0> - server_gen:241] - Handling sync request from PID <0.93.0> of type: {detach,<0.93.0>}.
{ok,flight_mode_on}
7> switch:status().
[TRACE - <0.87.0> - server_gen:241] - Handling sync request from PID <0.85.0> of type: status.
{ok,[{"12121212",<0.91.0>,[]},{"23232323",0,[]}]}
8> process_info(whereis(switch)).
[{registered_name,switch},
 {current_function,{server_gen,loop,2}},
 {initial_call,{server_gen,init,2}},
 {status,waiting},
 {message_queue_len,0},
 {links,[<0.91.0>]},
 {dictionary,[]},
 {trap_exit,true},
 {error_handler,error_handler},
 {priority,normal},
 {group_leader,<0.70.0>},
 {total_heap_size,1220},
 {heap_size,610},
 {stack_size,6},
 {reductions,4451},
 {garbage_collection,[{max_heap_size,#{error_logger => true,include_shared_binaries => false,
                                       kill => true,size => 0}},
                      {min_bin_vheap_size,46422},
                      {min_heap_size,233},
                      {fullsweep_after,65535},
                      {minor_gcs,18}]},
 {suspending,[]}]
9> exit(whereis(switch), kill).
true
10> is_process_alive(Mob1).
false
11> is_process_alive(Mob2).
true
\end{lstlisting}

The above procedure tests the behaviour of our system when the
\texttt{switch} abnormally exits.

As we can see from prompt line 10, linked \texttt{mobile} actors
will also exit when the \texttt{switch} abnormally exits.

The above behaviour is the expected behaviour for linked
processes which do not trap exits.

Furthermore, as we can see from prompt line 11, unlinked or
detached \texttt{mobile} actors survive when the \texttt{switch}
abnormally exits.

This of course can have unforeseen consequences if not properly
catered for.
\end{ans}

\Que{2}{
Suppose the \texttt{switch} terminates and is restarted by a
supervisor. Can you think of a solution which would allow the
\texttt{switch} to recover its previous state (\emph{i.e.}, the
list of subscriber MSISDNs and attached \texttt{mobile} phone
actors) as if nothing ever happened?
}

\begin{ans}
There are a number of possible approaches to solve this problem,
these include:

\begin{enumerate}
  \item using a database and maybe an in--memory cache which is
    kept up--to--date with the database; and
  \item using a third process as storage.
\end{enumerate}

The first solution is very trivial and easy to implement. I will
however go through the second more thoroughly.

\begin{figure}[H]
  \centering
  \includegraphics[width=10cm]{drawings/process1.pdf}
  \caption{A drawing of the initial setup.}
\end{figure}

The basic premise is that we split the generic server
architecture into two. The behaviour process and the state
process. Essentially, the behvaiour process will updated the
state process when a successful update to state is performed.

\begin{quote}
  \textbf{Note:} This of course comes with its own host of
  problems. Will it be synchronous or asynchronous? Should we
  send deltas (\emph{i.e.}, only small changes) or should we
  send the whole state? Nevertheless, I will ignore such
  discussion as they go beyond the point of this assignment.
\end{quote}

\begin{figure}[H]
  \centering
  \includegraphics[width=10cm]{drawings/process2.pdf}
  \caption{A drawing of the \texttt{switch} dying.}
\end{figure}

Having setup this architecture, when the behaviour process dies,
the supervisor will be informed.

\begin{figure}[H]
  \centering
  \includegraphics[width=10cm]{drawings/process3.pdf}
  \caption{A drawing of the supervisor requesting the last valid
  state.}
\end{figure}

Then, the supervisor will employ a special strategy which allows
it to get the last valid state of the process which has just
died by requesting it off of the associated state process.

\begin{figure}[H]
  \centering
  \includegraphics[width=10cm]{drawings/process4.pdf}
  \caption{A drawing of the supervisor restarting the
  \texttt{switch} with its last valid state.}
\end{figure}

Then the supervisor restarts the dead process with its last
valid state.

\begin{quote}
  \textbf{Note:} I would like to point out that this
  architecture is in fact very similar to a database
  architecture. We are just making the state process our
  in--memory database. Additionally, it has its own problems
  which have in the most part already been solved by mature
  databases.
\end{quote}

Additionally, I would like to describe what in my opinion is a
non--solution to the problem.

\begin{quote}
  \textbf{Non--solution:} \textit{To exit manually and return
    the state of the \texttt{switch} along with the reason for
    exiting. Then the respective supervisor will get the state
    of the process and it will be able to restart the
  \texttt{switch} with its last valid state.}
\end{quote}

This approach I think naturally emerges from the work we do
related to the capture of \texttt{EXIT} signals. However, as
shown in the below procedure if the \texttt{switch} truly exits
abnormally, it will not capture its own \texttt{EXIT} signals
even if the \texttt{trap\_exit} flag is set, as is the case for
the \texttt{switch} process.

\begin{lstlisting}[basicstyle=\small\ttfamily,breaklines=true]
1> c(log).
{ok,log}
2> c(server_gen).
{ok,server_gen}
3> c(switch).
{ok,switch}
4> switch:start().
[DEBUG - <0.105.0> - switch:88] - Starting switch process.
<0.105.0>
[TRACE - <0.105.0> - server_gen:132] - Init successful with state: [].
5> switch:subscribe("99115740").
[TRACE - <0.105.0> - server_gen:241] - Handling sync request from PID <0.85.0> of type: {subscribe,"99115740"}.
=ERROR REPORT==== 10-Dec-2023::16:24:41.652712 ===
Error in process <0.105.0> with exit value:
{undef,[{util,fetch,["99115740",1,[]],[]},
        {switch,handle,2,[{file,"switch.erl"},{line,128}]},
        {server_gen,loop,2,[{file,"server_gen.erl"},{line,242}]}]}

{error,timeout}
\end{lstlisting}

Of course, the above can be handled via the usage of
\texttt{try}--\texttt{catch} expressions. However, this is an
improper approach to handling such failures.

Firstly, this is because you would want such failures to be
immediately noticeable to the deployers of the system as,
evidently something bad happened during compilation/building and
secondly, because this still does not ensure complete fault
tolerance as a failure can still truly kill the system. 

\end{ans}

\end{document}
